

/**
    @defgroup IO IO-related classes and interfaces

    The main HepMC3 library contains the classes for the I/O of multiple event formats.

    Optionally the I/O capabilities can be implemented as plugin Reader/Writer classes compiled
    separately into dynamically loadable libraries and used via  RearedPlugin and WriterPlugin classes.
    Please note that all required libraries/dlls should be loadable.
    See examples for details.

    In some cases the fine tuning of the Reader/Writer classes behavior can be done using a
    map of string "options"

    @code{.cpp}
           void Reader::set_options(const std::map<std::string, std::string>& options)

           std::map<std::string, std::string> Reader::get_options() const
    @endcode

    The options for ReaderAsciiHepMC2
      "disable_pad_cross_sections"
      "pad_cross_section_value"/"pad_cross_section_error"
     If "disable_pad_cross_sections" is present the reader will keep a single cross-section per event, just
     in the HepMC2 style. This is pre-3.2.6 default behaviour. 
     Otherwise, the cross-section vector will be expanded to the size  of event weights. This is 3.2.6+ default behaviour.
     If present, "pad_cross_section_value"/"pad_cross_section_error" values will be inserted into the cross-section vector.
     Otherwise, the cross-sections and errors will be filled with zeros.
     

      "particle_flows_are_separated"
      "event_random_states_are_separated"
      "vertex_weights_are_separated"
      "particle_flows_are_separated"
     Regulate if the corresponding information from IO_GenEvent would be stored into multiple attributes as
     individual numbers, i.e. "separated" or as a single std::vector. The former behavior is used if
     the corresponding option name is present in the list of options, regardless of the option value.
     The later behavior is the default one.

    The option for WriterAscii and WriterAsciiHepMC2

     "float_printf_specifier"

     specifies the float printf specifier used for the output format of the floats.
     Two first characters from the  option value are used.
     The default behavior is equivalent to setting this option to "e" and results in the output formatted as
     " %.*e". To save the disk space one can use the "g" option, e.g.
    @code{.cpp}
    WriterAscii       outputA("someoutput.hepmc");
    auto optionsA =  outputA.get_options();
    optionsA["float_printf_specifier"] = "g";
    outputA.set_options(optionsA);
    @endcode
    This option will be the default on in the future.



    ###########################################################################
    @subsection links_mem Links
    ###########################################################################

    The relations between vertices and particles in GenEventData are encoded via
    members links1 and links2, wich are std::vector<int> containing object ids.
    Direct manipulations with links1 and links2 can be useful. For instance,
    when the events are saved in ROOT format, one can extract the information
    from links1 and links2 without reading whole event.
    In case links1[i] is particle, links2[i] is end vertex. In case links1[i] is
    vertex, links2[i] is outgoing particle. An example of usage is given below.
    @code{.cpp}
        // Andrii Verbytskyi, 2017, MPI fuer Physik
        // Here is a code to look for a scattered DIS electron  in HepMC3 event record using links.
        // The implementation is extended to provide example of links1, links2 usage.
        // Dummy code.
        GenEventData*  A=...
        ...
        int i;
        int j;
        int current_l=0;                             // If the incoming electron is the first particle in the list
        int vertex_l=0;                              // We set final vertex to some nonsense value.
        bool found_next_vertex=true;
        while(found_next_vertex)                     // Looking for the electron end vertex
        {
            found_next_vertex=false;
            for (i=0; i<A->links1.size(); i++)       // Points from to ...
                if (A->links1[i]>0 &&                // The link1 should be particle, i.e. >0
                    A->links1[i]==current_l+1)       // The link1 should be our electron
                {
                    vertex_l=A->links2[i];           // The end vertex of this electron is found
                    found_next_vertex=true;
                }
            std::vector<int> out;                    // Here we will save the outgoing particles
            if (found_next_vertex)
            {
                for (j=0; j<A->links1.size(); j++)   // Points from to ...
                    if (A->links1[j]<0 &&            // The link1 should be a vertex, i.e. <0
                        A->links1[j]==vertex_l)      // The link1 should be our end vertex
                        if (std::abs(A->particles_pid[A->links2[j]-1])==11)  // If the outgoing particle is e+/e-.
                            out.push_back(A->links2[j]);
                if (out.size()==0) {
                    printf("Warning: no electron in the new vertex.\n");
                    break;
                }
                else
                {
                    if (out.size()>1) printf("Warning: more than one electron in the new vertex.\n");
                    current_l=out.at(0)-1;           // Pick up the  first electron in the list and use it as current electron.
                }
            }
            if (A->particles_status[current_l]==1) break; // The end particle is stable. It is our scattered electron.
        }
        ...
        // Here we have cuts on electron
    @endcode

    <hr>




*/
